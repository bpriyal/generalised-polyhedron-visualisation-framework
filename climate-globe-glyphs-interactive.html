<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global Climate Polyhedron Glyph</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: 'Inter', sans-serif; color: white; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }

        h1 { margin: 0; font-size: 1.5rem; color: #38bdf8; text-transform: uppercase; letter-spacing: 2px; }
        .subtitle { font-size: 0.8rem; color: #94a3b8; margin-bottom: 20px; }
        .instruction { font-size: 0.75rem; color: #fbbf24; margin-top: 5px; font-weight: bold; background: rgba(251, 191, 36, 0.1); padding: 5px; display: inline-block; border-radius: 4px; border: 1px solid #fbbf24; }

        #legend-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid #334155;
            padding: 15px;
            border-radius: 8px;
            width: 260px;
            pointer-events: auto;
        }

        .legend-title { font-weight: bold; font-size: 0.9rem; margin-bottom: 10px; border-bottom: 1px solid #334155; padding-bottom: 5px; }
        
        #tooltip {
            position: absolute;
            background: rgba(2, 6, 23, 0.95);
            border: 1px solid #38bdf8;
            padding: 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            display: none;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            min-width: 150px;
        }

        .tooltip-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .tooltip-val { font-weight: bold; color: #e2e8f0; }
        .face-id { display: inline-block; width: 16px; height: 16px; text-align: center; line-height: 16px; background: #334155; border-radius: 50%; font-size: 0.6rem; margin-right: 5px; }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui-layer">
        <h1>Global Climate Glyphs</h1>
        <div class="subtitle">Real-time Representation on Interactive Globe</div>
        <div class="instruction">CLICK & DRAG a glyph to rotate it individually</div>
    </div>

    <!-- Exploded Legend (SVG) -->
    <div id="legend-container">
        <div class="legend-title">Face Encoding Map</div>
        <svg width="240" height="200" viewBox="-3 -4 6 7">
            <!-- Polygons -->
            <polygon points="0,0 1,1 -1,1" fill="#3b82f6" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="0" y="0.7" font-size="0.4" fill="white" text-anchor="middle">1</text>

            <polygon points="1,1 2,0 1,-1" fill="#bae6fd" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="1.3" y="0" font-size="0.4" fill="#0f172a" text-anchor="middle">2</text>

            <polygon points="1,-1 0,-2 -1,-1" fill="#22c55e" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="0" y="-1.3" font-size="0.4" fill="white" text-anchor="middle">3</text>

            <polygon points="-1,-1 -2,0 -1,1" fill="#a855f7" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="-1.3" y="0" font-size="0.4" fill="white" text-anchor="middle">4</text>

            <!-- Inner Faces -->
            <polygon points="0,0.5 0.5,1.5 -0.5,1.5" fill="#64748b" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="0" y="1.2" font-size="0.4" fill="white" text-anchor="middle">5</text>

            <polygon points="1.5,0.5 2.5,0 1.5,-0.5" fill="#1e293b" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="1.8" y="0" font-size="0.4" fill="white" text-anchor="middle">6</text>

            <polygon points="0,-1.5 0.5,-2.5 -0.5,-2.5" fill="#eab308" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="0" y="-2.2" font-size="0.4" fill="white" text-anchor="middle">7</text>

            <polygon points="-1.5,0.5 -2.5,0 -1.5,-0.5" fill="#ef4444" stroke="white" stroke-width="0.05" opacity="0.9"></polygon>
            <text x="-1.8" y="0" font-size="0.4" fill="white" text-anchor="middle">8</text>
        </svg>
        <div style="font-size: 0.7rem; color: #cbd5e1; margin-top: 10px; display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
            <div>1. Temp Dev</div>
            <div>2. Humidity</div>
            <div>3. Precip</div>
            <div>4. Wind Spd</div>
            <div>5. Clouds</div>
            <div>6. Pressure</div>
            <div>7. Zone</div>
            <div>8. UV Index</div>
        </div>
    </div>

    <div id="tooltip"></div>

    <script>
        // --- 1. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
        camera.position.set(0, 0, 320); // Move camera back to see globe

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.minDistance = 150;
        controls.maxDistance = 600;

        // --- 2. GLOBE SETUP ---
        const GLOBE_RADIUS = 80;
        const globeGroup = new THREE.Group();
        scene.add(globeGroup);

        const loader = new THREE.TextureLoader();
        loader.load('https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/World_map_blank_without_borders.svg/2000px-World_map_blank_without_borders.svg.png', 
            function(texture) {
                const sphereGeo = new THREE.SphereGeometry(GLOBE_RADIUS, 64, 64);
                const sphereMat = new THREE.MeshPhongMaterial({ 
                    map: texture, 
                    color: 0x8899aa,
                    specular: 0x111111,
                    shininess: 5,
                    transparent: true,
                    opacity: 0.9
                });
                const earth = new THREE.Mesh(sphereGeo, sphereMat);
                globeGroup.add(earth);
            }
        );

        // Atmosphere Glow (Optional subtle effect)
        const atmosGeo = new THREE.SphereGeometry(GLOBE_RADIUS + 2, 64, 64);
        const atmosMat = new THREE.MeshBasicMaterial({ color: 0x38bdf8, transparent: true, opacity: 0.1, side: THREE.BackSide });
        const atmosphere = new THREE.Mesh(atmosGeo, atmosMat);
        globeGroup.add(atmosphere);

        // --- 3. LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 50, 100);
        scene.add(sunLight);
        
        const backLight = new THREE.DirectionalLight(0x445566, 0.5);
        backLight.position.set(-100, 0, -50);
        scene.add(backLight);

        // --- 4. DATA ---
        const countries = [
            {name: "USA", lat: 37.09, lon: -95.71, zone: "Temperate"},
            {name: "Brazil", lat: -14.23, lon: -51.92, zone: "Tropical"},
            {name: "UK", lat: 55.37, lon: -3.43, zone: "Temperate"},
            {name: "France", lat: 46.22, lon: 2.21, zone: "Temperate"},
            {name: "South Africa", lat: -30.55, lon: 22.93, zone: "Arid"},
            {name: "India", lat: 20.59, lon: 78.96, zone: "Tropical"},
            {name: "China", lat: 35.86, lon: 104.19, zone: "Temperate"},
            {name: "Australia", lat: -25.27, lon: 133.77, zone: "Arid"},
            {name: "Japan", lat: 36.20, lon: 138.25, zone: "Temperate"},
            {name: "Russia", lat: 61.52, lon: 105.31, zone: "Polar"},
            {name: "Egypt", lat: 26.82, lon: 30.80, zone: "Arid"},
            {name: "Canada", lat: 56.13, lon: -106.34, zone: "Polar"},
            {name: "Mexico", lat: 23.63, lon: -102.55, zone: "Arid"},
            {name: "Germany", lat: 51.16, lon: 10.45, zone: "Temperate"},
            {name: "Nigeria", lat: 9.08, lon: 8.67, zone: "Tropical"},
            {name: "Argentina", lat: -38.41, lon: -63.61, zone: "Temperate"},
            {name: "Indonesia", lat: -0.78, lon: 113.92, zone: "Tropical"},
            {name: "Saudi Arabia", lat: 23.88, lon: 45.07, zone: "Arid"},
            {name: "Turkey", lat: 38.96, lon: 35.24, zone: "Temperate"},
            {name: "Greenland", lat: 71.70, lon: -42.60, zone: "Polar"}
        ];

        // --- 5. HELPER: LAT/LON TO VECTOR3 ---
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const z = (radius * Math.sin(phi) * Math.sin(theta));
            const y = (radius * Math.cos(phi));

            return new THREE.Vector3(x, y, z);
        }

        // --- 6. GEOMETRY (OCTAHEDRON) ---
        const baseVerts = [
            new THREE.Vector3(1,0,0), new THREE.Vector3(-1,0,0), 
            new THREE.Vector3(0,1,0), new THREE.Vector3(0,-1,0), 
            new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,-1)
        ];
        
        const faceIndices = [
            [0,2,4], [2,1,4], [1,3,4], [3,0,4], 
            [0,3,5], [3,1,5], [1,2,5], [2,0,5]
        ];

        // --- 7. COLOR MAPPERS ---
        function mapTemp(val) {
            if (val < -2) return new THREE.Color(0x3232ff);
            if (val < 2) return new THREE.Color(0xf0f0f0);
            return new THREE.Color(0xff3232);
        }
        function mapHumidity(val) {
            const intensity = Math.floor(val * 2.55); 
            return new THREE.Color(`rgb(${255-intensity}, ${255-intensity}, 255)`);
        }
        function mapPrecip(val) {
            if (val < 5) return new THREE.Color(0x32c832);
            if (val < 20) return new THREE.Color(0xffff32);
            return new THREE.Color(0xc83232);
        }
        function mapZone(val) {
            if (val === 'Arid') return new THREE.Color(0xffc864);
            if (val === 'Tropical') return new THREE.Color(0x10b981);
            if (val === 'Temperate') return new THREE.Color(0x64c864);
            return new THREE.Color(0x96c8ff);
        }

        // --- 8. CREATE GLYPHS ---
        const glyphs = [];
        const glyphGroup = new THREE.Group();
        globeGroup.add(glyphGroup); // Add glyphs to globe group so they rotate with it if we rotated globe

        countries.forEach((country, idx) => {
            const attrs = {
                name: country.name,
                temp: (Math.random() * 20) - 10,
                humidity: Math.random() * 100,
                precip: Math.random() * 30,
                wind: Math.random() * 50,
                cloud: Math.random(),
                pressure: 980 + Math.random() * 60,
                zone: country.zone,
                uv: Math.random() * 12
            };
            
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];

            faceIndices.forEach((face, faceIdx) => {
                let col = new THREE.Color();
                if (faceIdx === 0) col = mapTemp(attrs.temp);
                else if (faceIdx === 1) col = mapHumidity(attrs.humidity);
                else if (faceIdx === 2) col = mapPrecip(attrs.precip);
                else if (faceIdx === 3) { 
                    const sat = Math.floor(attrs.wind * 5);
                    col.set(`rgb(${sat}, 0, ${sat})`);
                }
                else if (faceIdx === 4) {
                    const l = attrs.cloud * 0.8 + 0.2;
                    col.setHSL(0, 0, l);
                }
                else if (faceIdx === 5) {
                    const norm = (attrs.pressure - 900) / 150;
                    col.setHSL(0, 0, norm);
                }
                else if (faceIdx === 6) col = mapZone(attrs.zone);
                else if (faceIdx === 7) {
                    const r = Math.floor(attrs.uv * 20);
                    col.set(`rgb(${r}, 0, 0)`);
                }

                face.forEach(vIdx => {
                    const v = baseVerts[vIdx];
                    vertices.push(v.x * 4.5, v.y * 4.5, v.z * 4.5); // Slightly larger
                    colors.push(col.r, col.g, col.b);
                });
            });

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({ 
                vertexColors: true, 
                flatShading: true,
                shininess: 30
            });

            const mesh = new THREE.Mesh(geometry, material);
            
            // Positioning on Globe
            // 1. Get Vector on Surface
            const pos = latLonToVector3(country.lat, country.lon, GLOBE_RADIUS + 8); // +8 for floating height
            mesh.position.copy(pos);
            
            // 2. Orient to face outwards
            mesh.lookAt(new THREE.Vector3(0,0,0)); // Look at center (points "down")
            // Depending on geometry, we might need to rotate 180?
            // Base geometry is aligned.
            
            // 3. Apply random wind rotation (local Z axis of the glyph)
            mesh.rotateZ(Math.random() * Math.PI * 2);

            mesh.userData = { id: idx, ...attrs };
            
            glyphGroup.add(mesh);
            glyphs.push(mesh);
            
            // Stem Line
            const startPos = latLonToVector3(country.lat, country.lon, GLOBE_RADIUS);
            const endPos = pos.clone();
            const lineGeo = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x94a3b8, opacity: 0.5, transparent: true }));
            glyphGroup.add(line);
        });

        // --- 9. INTERACTION LOGIC (STRICT) ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        
        let isDragging = false;
        let selectedGlyph = null;
        let previousMousePosition = { x: 0, y: 0 };

        // Attach listeners to canvas to be specific
        const canvas = renderer.domElement;

        canvas.addEventListener('mousedown', (event) => {
            // Calculate mouse pos
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(glyphs);
            
            if (intersects.length > 0) {
                // INTERSECTION FOUND: GLYPH CLICKED
                isDragging = true;
                selectedGlyph = intersects[0].object;
                
                // CRITICAL: Disable controls immediately
                controls.enabled = false;
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
                document.body.style.cursor = "move";
            }
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            selectedGlyph = null;
            // Re-enable controls
            controls.enabled = true;
            document.body.style.cursor = "default";
        });

        window.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            if (isDragging && selectedGlyph) {
                // DRAG LOGIC
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                // Rotate in local space
                selectedGlyph.rotateZ(deltaX * 0.01);
                selectedGlyph.rotateX(deltaY * 0.01);
                
                previousMousePosition = { x: event.clientX, y: event.clientY };
                tooltip.style.display = 'none';
                return;
            }

            // HOVER LOGIC
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(glyphs);

            if (intersects.length > 0) {
                if (!isDragging) { // Only show tooltip if not dragging
                    const data = intersects[0].object.userData;
                    tooltip.style.display = 'block';
                    tooltip.style.left = event.clientX + 15 + 'px';
                    tooltip.style.top = event.clientY + 15 + 'px';
                    
                    tooltip.innerHTML = `
                        <div style="color:#38bdf8; font-weight:bold; margin-bottom:5px;">${data.name}</div>
                        <div class="tooltip-row"><span class="face-id">1</span> Temp Dev: <span class="tooltip-val">${data.temp.toFixed(1)}Â°C</span></div>
                        <div class="tooltip-row"><span class="face-id">2</span> Humidity: <span class="tooltip-val">${data.humidity.toFixed(0)}%</span></div>
                        <div class="tooltip-row"><span class="face-id">3</span> Precip: <span class="tooltip-val">${data.precip.toFixed(1)}mm</span></div>
                        <div class="tooltip-row"><span class="face-id">7</span> Zone: <span class="tooltip-val" style="color:#eab308">${data.zone}</span></div>
                        <div style="margin-top:6px; font-size:0.65rem; color:#94a3b8; border-top:1px solid #334155; padding-top:2px;">
                            Click & Drag to Rotate
                        </div>
                    `;
                    document.body.style.cursor = "pointer";
                }
            } else {
                tooltip.style.display = 'none';
                if (!isDragging) document.body.style.cursor = "default";
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>